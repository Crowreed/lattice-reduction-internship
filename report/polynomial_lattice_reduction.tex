%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                                                                                                             %
%                                             ▗▄▄▖▗▄▄▄▖ ▗▄▄▖▗▄▄▄▖▗▄▄▄▖ ▗▄▖ ▗▖  ▗▖    ▗▄▄▄▖▗▄▄▄▖        ▗▄▄▄▖                                                  %
%                                            ▐▌   ▐▌   ▐▌     █    █  ▐▌ ▐▌▐▛▚▖▐▌      █    █            █                                                    %
%                                             ▝▀▚▖▐▛▀▀▘▐▌     █    █  ▐▌ ▐▌▐▌ ▝▜▌      █    █            █                                                    %
%                                            ▗▄▄▞▘▐▙▄▄▖▝▚▄▄▖  █  ▗▄█▄▖▝▚▄▞▘▐▌  ▐▌    ▗▄█▄▖▗▄█▄▖        ▗▄█▄▖                                                  %
%                                                                                                                                                             %
%        ▗▄▄▖  ▗▄▖ ▗▖ ▗▖  ▗▖▗▖  ▗▖ ▗▄▖ ▗▖  ▗▖▗▄▄▄▖ ▗▄▖ ▗▖       ▗▖    ▗▄▖▗▄▄▄▖▗▄▄▄▖▗▄▄▄▖ ▗▄▄▖▗▄▄▄▖    ▗▄▄▖ ▗▄▄▄▖▗▄▄▄ ▗▖ ▗▖ ▗▄▄▖▗▄▄▄▖▗▄▄▄▖ ▗▄▖ ▗▖  ▗▖          %
%        ▐▌ ▐▌▐▌ ▐▌▐▌  ▝▚▞▘ ▐▛▚▖▐▌▐▌ ▐▌▐▛▚▞▜▌  █  ▐▌ ▐▌▐▌       ▐▌   ▐▌ ▐▌ █    █    █  ▐▌   ▐▌       ▐▌ ▐▌▐▌   ▐▌  █▐▌ ▐▌▐▌     █    █  ▐▌ ▐▌▐▛▚▖▐▌          %
%        ▐▛▀▘ ▐▌ ▐▌▐▌   ▐▌  ▐▌ ▝▜▌▐▌ ▐▌▐▌  ▐▌  █  ▐▛▀▜▌▐▌       ▐▌   ▐▛▀▜▌ █    █    █  ▐▌   ▐▛▀▀▘    ▐▛▀▚▖▐▛▀▀▘▐▌  █▐▌ ▐▌▐▌     █    █  ▐▌ ▐▌▐▌ ▝▜▌          %
%        ▐▌   ▝▚▄▞▘▐▙▄▄▖▐▌  ▐▌  ▐▌▝▚▄▞▘▐▌  ▐▌▗▄█▄▖▐▌ ▐▌▐▙▄▄▖    ▐▙▄▄▖▐▌ ▐▌ █    █  ▗▄█▄▖▝▚▄▄▖▐▙▄▄▖    ▐▌ ▐▌▐▙▄▄▖▐▙▄▄▀▝▚▄▞▘▝▚▄▄▖  █  ▗▄█▄▖▝▚▄▞▘▐▌  ▐▌          %
%                                                                                                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                                                                                                             %
% Pas de sous-fichiers                                                                                                                                        %
%                                                                                                                                                             %
% Le fichier parent est : lattice_reduction.tex                                                                                                               %
%                                                                                                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\lettrine{L}{a} réduction des réseaux polynomiaux est une étape essentielle dans plusieurs applications algorithmiques, en particulier dans le décodage efficace des codes de Reed-Solomon généralisés. Cette opération vise à transformer une base quelconque d'un réseau polynomial en une base simplifiée. Dans cette section, nous détaillerons les principaux concepts, outils et algorithmes permettant de réaliser cette réduction en temps polynomial. On notera \( \K \) un corps quelconque.

\section{Généralités et notion de base d'ordre}
Soit \( F \in \F[x]^{m \x n},\) et un \textbf{degré de précision} \( \sigma \in \N \). On définit \[ (F, \sigma):= \{v \in \F[x]^{1 \x m}  ~|~  vF = 0 \mod x^\sigma\} \]

\begin{proposition}
	\( (F, \sigma) \) est un réseau polynomial de dimension \( m \).
\end{proposition}

On va s'intérésser à étudier les bases de ce réseau et définir une notion de base réduite.

\begin{definition}
	Une \( (F, \sigma) \)-\textbf{base d'ordre} est une base \footnote{au sens des \( \F[x] \)-modules} de \( (F, \sigma) \) de degré minimale.
\end{definition}

Quelle est la définition du degré ? Que signifie minimale dans ce contexte ?

\begin{definition}
	Soit \( F \in \F[x]^{m \x n} \). On dit que \( F \) est \textbf{réduite par ligne} si, pour tout \( U \in \F[x]^{m \x m} \) unimodulaire, on a : 
    \[ \rdeg(F) \leq_{ob} \rdeg(UF). \]
\end{definition}

Pour parler d'un minimum, il faut un ordre total. On voit enfin la nouvelle définition de base réduite.

\begin{definition}
	Une \textbf{base d'ordre} est une base de \( (F, \sigma) \) qui est réduite par ligne.
\end{definition}

On peut définir une notion de base d'ordre en incluant la notion de décalage des degrés, on munit \( (F, \sigma) \) d'un vecteur de décalage \( s \), qu'on notera \( (F, \sigma, s) \), on peut alors dire qu'une base d'ordre de cet ensemble est une base d'ordre de \( (F x^s, \sigma) \), on peut l'interpréter intuitivement comme une base réduite pour un décalage, qui sera utile dans le chapitre 6.

L'existence d'une base réduite est garantie, mais elle n'est pas nécessairement unique. Pour assurer l'unicité, une condition supplémentaire est requise : la forme de Popov.

\begin{proof}[Preuve naïve (incorrecte)]
	Considérons le minimum de tous les \(\)$\rdeg(P U)$ triés, pour toutes les matrices unimodulaires \( U \in \F[x]^{m \x m} \).  
	
	Toute base \( PU \) ayant un degré minimal est une base d'ordre. Attention : l'ordre \( \leq_{ob} \) n'est pas un ordre total. En effet, il est possible d'avoir deux bases dont les degrés en ligne sont respectivement \( (1,2,3) \) et \( (1,1,4) \). On ne peut pas encore garantir l'existence d'un minimum !
\end{proof}

%Est-ce qu'on pourrait faire un lien avec le dev de Taylor

\begin{definition}
	Soit \( A \in \F[x]^{m \x n} \) et soit \( v = \rdeg_u(A) \). On définit la \textbf{matrice des coefficients dominants} \footnote{La matrice des coefficients dominants est accessible dans \texttt{SageMath} via la méthode \texttt{leading\_matrix()}.}
     de \( A \), notée \( \lcoeff(A) \in \F^{m \x n} \), comme étant la matrice obtenue en extrayant la partie constante de \( x^{-v} A\), c'est-à-dire :
	\[
	\lcoeff(A) = \lim_{x \to \infty} x^{-v} A.
	\]
\end{definition}

\begin{example}
	Soit 
	\[
	F = 
	\begin{pmatrix}
		1 & 0 & 1 \\
		x & 1 & 1 + x \\
		1 & x^2 + x^3 & x
	\end{pmatrix}
    , \quad
    \vec{v} := \rdeg(F) = (0,1,3)
	\]
	
	Alors
	\[\displaystyle
	x^{-\vec{v}} \cdot F =
	\begin{pmatrix}
		1 & 0 & 1\\
		1 & x^{-1} & x^{-1} + 1 \\
		x^{-3} & x^{-1} + 1 & x^{-2}\\
	\end{pmatrix}
	= 
	\begin{pmatrix}
		1 & 0 & 1 \\
		1 & 0 & 1 \\
		0 & 1 & 0 
	\end{pmatrix}
	+ 
	\OO_{x \to \infty}(x^{-1})
	\]
\end{example}

\begin{proposition}[Transitivité, revisitée]
	Soient \( c := b \cdot A \), \( v = \rdeg_u(A) \) et \( w = \rdeg_v(b) \).
	
	Si \( \lcoeff(A) \) est \textbf{injective à gauche}, alors \( \rdeg_u(c) = w \).
\end{proposition}


\begin{remark}
    On a donc l'égalité par rapport à la proposition 4.4.
\end{remark}
\begin{proposition}
	Soit \( A \) une matrice. Si \( \lcoeff(A) \) est injective à gauche, alors \( A \) est réduite par ligne.
\end{proposition}

Maintenant que l'on connaît la définition d'une base réduite et un critère pour la définir comment la calculer efficacement ?

\begin{definition}
    On définit le \textbf{pivot} d'une ligne comme l'élément non nul de degré maximal le plus à droite dans cette ligne.
\end{definition}

\begin{definition}
	Soit \( W \in \F[x]^{m \x n} \). La matrice \( W \) est dite en \textbf{forme Popov faible} si chaque ligne de \( W \) possède un pivot, et si les indices de colonnes de ces pivots sont distincts deux à deux.
\end{definition}

\begin{example}
	Soit $ W_1, W_2 \in M_2(\Z_7 [x])$ tel que
	\[
    W_1=
	\begin{pmatrix}
        3x + 4 & \fcolorbox{white}{red!20}{$x^9$} \\
        5 & \fcolorbox{white}{red!20}{$x^2+1$}
    \end{pmatrix}
    ,~W_2= 
    \begin{pmatrix}
        \fcolorbox{white}{red!20}{$2x^7 + 5x^5 + 3x + 4$} & x^5 \\
        5 & \fcolorbox{white}{red!20}{$x^2+1$}
    \end{pmatrix}
	\]
	On note les pivots en rouge. $W_1$ n'est pas en forme de Popov faible car les pivots sont sur la même colonne, et $W_2$ est en forme Popov faible , car les pivots, ont des indices de colonnes distincts.
\end{example}	

Pour transformer une matrice en forme Popov faible, on peut utiliser l'algorithme proposé dans \parencite{Mulders2003}, qui fournit une méthode systématique pour y parvenir en appliquant des transformations unimodulaires par lignes.

\begin{definition}
    On appelle \textbf{transformation simple} de la ligne \(k\) sur la ligne \(l\) l'opération consistant à soustraire \(c x^e\) fois la ligne \(k\) à la ligne \(l\), où \(c \in \F\) et \(e \in \mathbb{N}\). On dit qu'elle est du \textbf{premier type} si les pivots de la ligne \( k \) et de la ligne \( l \) ont les mêmes indices et du \textbf{deuxième type} sinon.
\end{definition}

%Une suite décroissante de row degree doit être stable, lien avec base de grobner
\footnote{L'algorithme suivant est disponible dans \texttt{SageMath} via la méthode \texttt{weak\_popov\_form()}.}

\begin{smallalgo}{WeakPopovForm \parencite{Mulders2003} }{algo:WeakPopovForm}
    \KwIn{\( \mathcal{M} \in \F[x]^{n \times m} \)}
    \KwOut{\( \mathcal{N} \) en forme de Popov faible, obtenue par des transformations simples de premier type appliquées à \( \mathcal{M} \)}
    
    \( A \gets \text{copie}(\mathcal{M}) \)\;
    
    \While{\( A \) n’est pas en forme de Popov faible}{
       Appliquer une transformation simple du premier type à \( A \)\;
    }
    
    \( \mathcal{N} \gets \text{copie}(A) \)\;
    \KwRet{\( \mathcal{N} \)}
\end{smallalgo}

\begin{theoreme}[Correction et complexité]
    \leavevmode\vspace{0.5\baselineskip}
    
    L'algorithme \textsc{WeakPopovForm} est correct. Sa complexité est bornée par $\OO(n m r d^2)$ opérations dans le corps de base, où $r$ désigne le rang de la matrice $M$, et $d$ une borne supérieure sur le degré des coefficients de $\mathcal{M}$.
\end{theoreme}

\begin{example}
	\[
    \begin{pmatrix}
        3x + 4 & \fcolorbox{white}{red!20}{$x^9$} \\
        5 & \fcolorbox{white}{red!20}{$x^2+1$}
    \end{pmatrix}
	\xrightarrow{(1)}
	\begin{pmatrix}
        2x^7+3x + 4 & \fcolorbox{white}{red!20}{$6x^7$} \\
        5 & \fcolorbox{white}{red!20}{$x^2+1$}
    \end{pmatrix}\xrightarrow{(2)}
	\begin{pmatrix}
        \fcolorbox{white}{red!20}{$2x^7 + 5x^5 + 3x + 4$} & x^5 \\
        5 & \fcolorbox{white}{red!20}{$x^2+1$}
    \end{pmatrix}
	\]
	
	\begin{enumerate}
		\item Ajouter \( 6 x^7 \) fois la deuxième ligne à la première ligne.
		\item Ajouter \( x^5 \) fois la deuxième ligne à la première ligne.
	\end{enumerate}
	
	La matrice finale est en forme Popov faible, les pivots ont des indices de colonnes distincts.
	
\end{example}
\begin{theoreme}
    Toute matrice en \textit{forme Popov faible} est réduite par ligne.
\end{theoreme}


\section{Algorithmes de calculs de base d'ordre}

Cette section va montrer qu'il existe des algorithmes plus rapide que \parencite{Mulders2003} pour calculer des bases d'ordres.

\subsection{Cas initial quand \( \sigma = 1 \)}

Si \( \sigma = 1 \), alors 

$$
\begin{aligned}
    (F, \sigma) & = \{ v \in \F[x]^{1 \x m}  ~|~  vF = 0 \mod x^1 \} \\
    &= \{ v \in \F^{1 \x m}  ~|~  vF = 0 \}
\end{aligned}
$$
Soit \( F \in \F^{m \x n} \), nous cherchons une base de \( (F, 1) \).

On remarque que si 
\[
\begin{pmatrix} 
	S \\
	K 
\end{pmatrix} 
F =
\begin{pmatrix} 
	R \\
	0 
\end{pmatrix}
\text{avec } 
 R 
 \text{ de rang maximal}
\]

alors
\[
\begin{pmatrix}
	xS \\
	K 
\end{pmatrix} 
F = 
\begin{pmatrix} 
	xR \\ 
	0 
\end{pmatrix} 
= 0 \mod x
\]
ce qui implique que 
\(
\begin{pmatrix}
	xS \\
	K 
\end{pmatrix}
\text{ est une base de }
(F, 1)
\)
Il existe des candidats naturels pour \( S \) et \( K \) : \( K \)  le noyau de $F$ et \( S \) le supplémentaire de $K$. On pourra choisir le noyau \( K \) utilisant les lignes de \( F \) de plus petit degré, une façon de les calculer consiste alors à obtenir la forme échelonnée par lignes de \( F \), avec une bonne permutation de façon à choisir les lignes de plus petit degrés, ceci aura son importance par la suite.

Il faut donc calculer une décomposition:
\[
\underbrace{
    \begin{pmatrix}
        L_r & 0 \\
        G   & I_{m-r} 
    \end{pmatrix}}_{L} 
 \cdot 
\begin{bmatrix}
    e_{\tau(1)} \\
    \vdots \\
    e_{\tau(n)}
\end{bmatrix} \cdot F =  
\underbrace{
    \begin{pmatrix}
        E' \\
        0 
    \end{pmatrix}
}_{E}
\]
où \( E \) est échelonnée en ligne, \( L \) est triangulaire inférieure, \( r \)est le rang de \( E \) et \( \tau \) est une permutation.

\vspace{0.2cm}

\begin{smallalgo}{Basis}{algo:Basis}
    \LinesNumbered 
    
    \KwIn{\( F \in (\F[x]_{\leq 0})^{m \times n} \), un vecteur de décalage \( s \).}
    \KwOut{Une \( (F, 1, s) \)-base d’ordre et son degré de ligne \( s \)-décalé.}
    
    On suppose que \( s \) est croissant.\;
    
    Calculer une forme ligne échelonnée \( F = \tau \cdot L \cdot E \) avec :\;
    \Indp
    \Indm  
    \KwRet{
        \(
        \begin{pmatrix} 
            xL_r & 0 \\ 
            G    & I_{m-r} 
        \end{pmatrix},
        \quad
        \tau^{-1}s + [1_r, 0_{n-r}]
        \)
    }
\end{smallalgo}

\vspace{0.2cm}

L'algorithme Basis calcul correctement une base d'ordre de \( (F, 1) \) d'après la construction ci-dessus, l'hypothèse que \( s \) est croissant est primordiale pour obtenir une base d'ordre. On ne cherchera pas à redémontrer ce résultat.

\subsection{Algorithmes pour le cas général}

On va devoir découper le problème pour trouver une base d'ordre pour \( \sigma > 1 \). 

\begin{theoreme}
    \leavevmode\vspace{0.5\baselineskip}
    
    Soit \( P_1\), \( P_2 \) des bases d'ordre de \( (F, \sigma_1)\) et \((F, \sigma_2)  \) respectivement, \( M \in \F [x]^{m \x n} \) tel que \( P_1F = x^{\sigma_1} M\). 
    
    Alors: \( P_2 P_1 \) est une base d'ordre de \( (F, \sigma_1 + \sigma_2 ) \).
\end{theoreme}

On peut découper par pas de \( 1 \), on se doute qu'il y aura plus efficace juste après ces lignes, on présente un algorithme itératif \textbf{quadratique}.
\[ 
(F, 1) \rightarrow (F, 2) \rightarrow (F, 3) \rightarrow \cdots (F, \sigma-1) \rightarrow  (F, \sigma) 
\]

\begin{smallalgo}{M-Basis}{algo:M-Basis}
    
    \KwIn{\( F \in (\mathbb{F}[x]_{<\sigma})^{m \times n} \), un vecteur de décalage \( \vec{s} \), \( \sigma \in \mathbb{N} \)}
    \KwOut{Une \( (F, \sigma, \vec{s}) \)-base d’ordre et son degré de ligne \( \vec{s} \)}
    
    
    \( P_0 \gets \hyperref[algo:Basis]{\emph{Basis}}(F \bmod x) \)\;
    
    \For{\( k \) de \( 1 \) à \( \sigma - 1 \)}{
        \( F' \gets x^{-k} P_{k-1} F \)\tcp*[r]{Décalage du problème}
        \( M_k \gets \hyperref[algo:Basis]{\emph{Basis}}(F' \bmod x) \)\;
        \( P_k \gets M_k P_{k-1} \)\;
    }
    
    \KwRet{\( P_{\sigma -1} \)}
\end{smallalgo}

\begin{theoreme}
    La complexité de l'algorithme \hyperref[algo:Basis]{\emph{Basis}} est \( \OO(m^\omega \sigma^2) \) opérations dans le corps de base.
\end{theoreme}

\begin{remark}
    \leavevmode\vspace{0.5\baselineskip}
    
    \begin{itemize}
        \item On peut réaliser la ligne 4 en \( \OO (m^\omega \sigma)\), la ligne 5 est en \( \OO (m^\omega) \) car les coefficients sont entiers.
        \item Il faut voir la ligne 3 comme un décalage.
        \item On se sert du théorème 5.3 pour prouver la correction de l'algorithme.
    \end{itemize}
\end{remark}

On présente maintenant un algorithme sur le principe diviser-pour-régner \textbf{quasi-linéaire} qui découpe la précision en \(2\).
\[ 
(F, 1) \rightarrow (F, 2) \rightarrow (F, 4) \rightarrow \cdots \rightarrow \left(F, \frac{\sigma}{2}\right) \rightarrow  (F, \sigma) 
\]

\begin{smallalgo}{PM-Basis}{algo:PM-Basis}
    
    \LinesNumbered 
    \DontPrintSemicolon
    
    \KwIn{\( F \in (\mathbb{F}[x]_{<\sigma})^{m \times n} \), un vecteur de décalage \( \vec{s} \), \( \sigma \in \mathbb{N} \)}
    \KwOut{Une \( (F, \sigma, \vec{s}) \)-base d’ordre et son degré de ligne \( \vec{s} \)}
    
    \eIf{\( \sigma = 1 \)}{
        \KwRet{\hyperref[algo:Basis]{\emph{Basis}}\( (F \bmod x) \)}\;
    }{
        \( P_{\text{low}} \gets \textsc{PM-Basis}(F, \lfloor \sigma/2 \rfloor) \)\tcp*[r]{Premier sous-problème}
        Soit \( F' \) tel que \( P_{\text{low}} F = x^{k} F' \)\tcp*[r]{Décalage du problème}
        \( P_{\text{high}} \gets \textsc{PM-Basis}(F', \lfloor \sigma/2 \rfloor) \)\tcp*[r]{Deuxième sous-problème}
        \KwRet{\( P_{\text{high}} \cdot P_{\text{low}} \)}\tcp*[r]{Résoudre le problème original}
    }
\end{smallalgo}



\begin{theoreme}
	La complexité de l'algorithme \hyperref[algo:PM-Basis]{\emph{PM-Basis}} est \( \OO(\MM(m, \sigma) \log(\sigma)) \) opérations dans le corps de base.
\end{theoreme}
    
\begin{remark}
    \leavevmode\vspace{0.5\baselineskip}
    
    \begin{itemize}
        \item Il faut voir la ligne 5 comme un décalage.
        \item La complexité peut se calculer en écrivant l'arbre binaire associé.
        \item On se sert du théorème 5.3 pour prouver la correction de l'algorithme.
    \end{itemize}
\end{remark}

Les algorithmes que nous avons vus sont des algorithmes pour calculer des bases d'ordre et non réduire des matrices par lignes.